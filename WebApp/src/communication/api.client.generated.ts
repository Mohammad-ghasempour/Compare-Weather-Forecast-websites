//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> },
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
  }

  /**
   * @return Success
   */
  date(
    dateQuery_Date: Date,
    cityQuery_City: string,
  ): Promise<WeatherForecastDto[]> {
    let url_ = this.baseUrl + '/api/weatherforecast/date?';
    if (dateQuery_Date === undefined || dateQuery_Date === null)
      throw new Error(
        "The parameter 'dateQuery_Date' must be defined and cannot be null.",
      );
    else
      url_ +=
        'DateQuery.Date=' +
        encodeURIComponent(
          dateQuery_Date ? '' + dateQuery_Date.toISOString() : '',
        ) +
        '&';
    if (cityQuery_City === undefined || cityQuery_City === null)
      throw new Error(
        "The parameter 'cityQuery_City' must be defined and cannot be null.",
      );
    else
      url_ += 'CityQuery.City=' + encodeURIComponent('' + cityQuery_City) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDate(_response);
    });
  }

  protected processDate(response: Response): Promise<WeatherForecastDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(WeatherForecastDto.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('Bad Request', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<WeatherForecastDto[]>(null as any);
  }

  /**
   * @return Success
   */
  between(
    betweenDateQuery_From: Date,
    betweenDateQuery_To: Date,
    cityQuery_City: string,
  ): Promise<WeatherForecastDto[]> {
    let url_ = this.baseUrl + '/api/weatherforecast/between?';
    if (betweenDateQuery_From === undefined || betweenDateQuery_From === null)
      throw new Error(
        "The parameter 'betweenDateQuery_From' must be defined and cannot be null.",
      );
    else
      url_ +=
        'BetweenDateQuery.From=' +
        encodeURIComponent(
          betweenDateQuery_From ? '' + betweenDateQuery_From.toISOString() : '',
        ) +
        '&';
    if (betweenDateQuery_To === undefined || betweenDateQuery_To === null)
      throw new Error(
        "The parameter 'betweenDateQuery_To' must be defined and cannot be null.",
      );
    else
      url_ +=
        'BetweenDateQuery.To=' +
        encodeURIComponent(
          betweenDateQuery_To ? '' + betweenDateQuery_To.toISOString() : '',
        ) +
        '&';
    if (cityQuery_City === undefined || cityQuery_City === null)
      throw new Error(
        "The parameter 'cityQuery_City' must be defined and cannot be null.",
      );
    else
      url_ += 'CityQuery.City=' + encodeURIComponent('' + cityQuery_City) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processBetween(_response);
    });
  }

  protected processBetween(response: Response): Promise<WeatherForecastDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(WeatherForecastDto.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('Bad Request', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<WeatherForecastDto[]>(null as any);
  }

  /**
   * @return Success
   */
  week(week: number, cityQuery_City: string): Promise<WeatherForecastDto[]> {
    let url_ = this.baseUrl + '/api/weatherforecast/week?';
    if (week === undefined || week === null)
      throw new Error(
        "The parameter 'week' must be defined and cannot be null.",
      );
    else url_ += 'Week=' + encodeURIComponent('' + week) + '&';
    if (cityQuery_City === undefined || cityQuery_City === null)
      throw new Error(
        "The parameter 'cityQuery_City' must be defined and cannot be null.",
      );
    else
      url_ += 'CityQuery.City=' + encodeURIComponent('' + cityQuery_City) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: RequestInit = {
      method: 'GET',
      headers: {
        Accept: 'text/plain',
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processWeek(_response);
    });
  }

  protected processWeek(response: Response): Promise<WeatherForecastDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ''
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(WeatherForecastDto.fromJS(item));
        } else {
          result200 = <any>null;
        }
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        return throwException('Bad Request', status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          'An unexpected server error occurred.',
          status,
          _responseText,
          _headers,
        );
      });
    }
    return Promise.resolve<WeatherForecastDto[]>(null as any);
  }
}

export class WeatherForecastDto implements IWeatherForecastDto {
  city?: string | undefined;
  date?: Date;
  weatherType?: string | undefined;
  temperature?: number;
  windspeed?: number;
  windDirection?: number;
  windspeedGust?: number;
  pressure?: number;
  humidity?: number;
  probOfRain?: number;
  amountRain?: number;
  cloudAreaFraction?: number;
  fogAreaFraction?: number;
  probOfThunder?: number;
  source?: WeatherSourceDto;

  constructor(data?: IWeatherForecastDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.city = _data['city'];
      this.date = _data['date']
        ? new Date(_data['date'].toString())
        : <any>undefined;
      this.weatherType = _data['weatherType'];
      this.temperature = _data['temperature'];
      this.windspeed = _data['windspeed'];
      this.windDirection = _data['windDirection'];
      this.windspeedGust = _data['windspeedGust'];
      this.pressure = _data['pressure'];
      this.humidity = _data['humidity'];
      this.probOfRain = _data['probOfRain'];
      this.amountRain = _data['amountRain'];
      this.cloudAreaFraction = _data['cloudAreaFraction'];
      this.fogAreaFraction = _data['fogAreaFraction'];
      this.probOfThunder = _data['probOfThunder'];
      this.source = _data['source']
        ? WeatherSourceDto.fromJS(_data['source'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): WeatherForecastDto {
    data = typeof data === 'object' ? data : {};
    let result = new WeatherForecastDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['city'] = this.city;
    data['date'] = this.date ? this.date.toISOString() : <any>undefined;
    data['weatherType'] = this.weatherType;
    data['temperature'] = this.temperature;
    data['windspeed'] = this.windspeed;
    data['windDirection'] = this.windDirection;
    data['windspeedGust'] = this.windspeedGust;
    data['pressure'] = this.pressure;
    data['humidity'] = this.humidity;
    data['probOfRain'] = this.probOfRain;
    data['amountRain'] = this.amountRain;
    data['cloudAreaFraction'] = this.cloudAreaFraction;
    data['fogAreaFraction'] = this.fogAreaFraction;
    data['probOfThunder'] = this.probOfThunder;
    data['source'] = this.source ? this.source.toJSON() : <any>undefined;
    return data;
  }
}

export interface IWeatherForecastDto {
  city?: string | undefined;
  date?: Date;
  weatherType?: string | undefined;
  temperature?: number;
  windspeed?: number;
  windDirection?: number;
  windspeedGust?: number;
  pressure?: number;
  humidity?: number;
  probOfRain?: number;
  amountRain?: number;
  cloudAreaFraction?: number;
  fogAreaFraction?: number;
  probOfThunder?: number;
  source?: WeatherSourceDto;
}

export class WeatherSourceDto implements IWeatherSourceDto {
  dataProvider?: string | undefined;

  constructor(data?: IWeatherSourceDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.dataProvider = _data['dataProvider'];
    }
  }

  static fromJS(data: any): WeatherSourceDto {
    data = typeof data === 'object' ? data : {};
    let result = new WeatherSourceDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['dataProvider'] = this.dataProvider;
    return data;
  }
}

export interface IWeatherSourceDto {
  dataProvider?: string | undefined;
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any,
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any,
): any {
  throw new ApiException(message, status, response, headers, result);
}
